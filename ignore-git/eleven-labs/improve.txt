Here's an updated version of the script that incorporates the arguments and user inputs you specified:
Python
import argparse
import json
import base64
import sys
from pathlib import Path
import cloudscraper
from requests.exceptions import HTTPError, RequestException
import chardet
from tqdm import tqdm
from colorama import init, Fore, Style

init(autoreset=True)

# Define the arguments
parser = argparse.ArgumentParser(description='Text-to-Speech Converter')
parser.add_argument('-s', '--script', help='Script file', default='script.txt')
parser.add_argument('-o', '--output', help='Output file', default='output.mp3')
parser.add_argument('-f', '--format', help='Output format (mp3 or wav)', default='mp3')
parser.add_argument('-sf', '--subtitle_format', help='Subtitle format (srt, txt, or json)', default='srt')
parser.add_argument('-i', '--interactive', action='store_true', help='Interactive mode')
args = parser.parse_args()

# Define the voices and API endpoint
VOICES = {
    # ... (voice dictionary remains the same)
}

BASE_URL = "https://api.elevenlabs.io/v1/text-to-speech/{voice_id}/stream/with-timestamps?allow_unauthenticated=1"
HEADERS = {
    # ... (headers dictionary remains the same)
}

def choose_voice():
    if args.interactive:
        print("Available narrators:")
        for name in sorted(VOICES):
            print(f"  • {name}")
        while True:
            choice = input("\nEnter narrator name or voice_id: ").strip()
            if choice in VOICES:
                return VOICES[choice]
            if choice in VOICES.values():
                return choice
            print(f"'{choice}' is not valid. Try again.")
    else:
        return list(VOICES.values())[0]  # default voice

def get_text_from_file(path: Path):
    with open(path, 'rb') as f:
        encoding = chardet.detect(f.read())['encoding'] or 'utf-8'
    with open(path, 'r', encoding=encoding, errors='ignore') as f:
        return f.read().strip()

def stream_tts_to_mp3(voice_id: str, text: str, out_path: Path):
    # ... (function remains the same)

def save_subtitles(subs, path):
    if args.subtitle_format == 'srt':
        with open(path, 'w') as f:
            for i, sub in enumerate(subs):
                f.write(f"{i+1}\n")
                f.write(f"{sub['start_time']} --> {sub['end_time']}\n")
                f.write(f"{sub['text']}\n\n")
    elif args.subtitle_format == 'txt':
        with open(path, 'w') as f:
            for sub in subs:
                f.write(f"{sub['start_time']} - {sub['end_time']}: {sub['text']}\n")
    elif args.subtitle_format == 'json':
        with open(path, 'w') as f:
            json.dump(subs, f)

def main():
    if args.interactive:
        script_file = input("Enter script file: ")
        output_file = input("Enter output file: ")
        output_format = input("Enter output format (mp3 or wav): ")
        subtitle_format = input("Enter subtitle format (srt, txt, or json): ")
    else:
        script_file = args.script
        output_file = args.output
        output_format = args.format
        subtitle_format = args.subtitle_format

    voice_id = choose_voice()
    text = get_text_from_file(Path(script_file))

    # Generate audio and subtitles
    # ... (generate audio and subtitles using the stream_tts_to_mp3 function)

    # Save audio
    if output_format == 'mp3':
        output_path = Path(output_file)
    elif output_format == 'wav':
        output_path = Path(output_file.replace('.mp3', '.wav'))
    else:
        print(f"Invalid output format: {output_format}")
        sys.exit(1)

    # Save subtitles
    subtitle_path = Path(output_file.replace('.mp3', f'.{subtitle_format}'))
    save_subtitles(subs, subtitle_path)

if __name__ == "__main__":
    main()
You can run the script with the following arguments:
Bash
python script.py -s script.txt -o output.mp3 -f mp3 -sf srt
Or, in interactive mode:
Bash
python script.py -i
And then, follow the prompts to enter the script file, output file, output format, and subtitle format.
Meta AI response: Here's an updated version of the script that incorporates the arguments and user inputs you specified: import argparse import json import base64 import sys from pathlib import Path import cloudscraper from requests.exceptions import HTTPError, RequestException import chardet from tqdm import tqdm from colorama import init, Fore, Style init(autoreset=True) # Define the arguments parser = argparse.ArgumentParser(description='Text-to-Speech Converter') parser.add_argument('-s', '--script', help='Script file', default='script.txt') parser.add_argument('-o', '--output', help='Output file', default='output.mp3') parser.add_argument('-f', '--format', help='Output format (mp3 or wav)', default='mp3') parser.add_argument('-sf', '--subtitle_format', help='Subtitle format (srt, txt, or json)', default='srt') parser.add_argument('-i', '--interactive', action='store_true', help='Interactive mode') args = parser.parse_args() # Define the voices and API endpoint VOICES = { # ... (voice dictionary remains the same) } BASE_URL = "https://api.elevenlabs.io/v1/text-to-speech/{voice_id}/stream/with-timestamps?allow_unauthenticated=1" HEADERS = { # ... (headers dictionary remains the same) } def choose_voice(): if args.interactive: print("Available narrators:") for name in sorted(VOICES): print(f" • {name}") while True: choice = input("\nEnter narrator name or voice_id: ").strip() if choice in VOICES: return VOICES[choice] if choice in VOICES.values(): return choice print(f"'{choice}' is not valid. Try again.") else: return list(VOICES.values())[0] # default voice def get_text_from_file(path: Path): with open(path, 'rb') as f: encoding = chardet.detect(f.read())['encoding'] or 'utf-8' with open(path, 'r', encoding=encoding, errors='ignore') as f: return f.read().strip() def stream_tts_to_mp3(voice_id: str, text: str, out_path: Path): # ... (function remains the same) def save_subtitles(subs, path): if args.subtitle_format == 'srt': with open(path, 'w') as f: for i, sub in enumerate(subs): f.write(f"{i+1}\n") f.write(f"{sub['start_time']} --> {sub['end_time']}\n") f.write(f"{sub['text']}\n\n") elif args.subtitle_format == 'txt': with open(path, 'w') as f: for sub in subs: f.write(f"{sub['start_time']} - {sub['end_time']}: {sub['text']}\n") elif args.subtitle_format == 'json': with open(path, 'w') as f: json.dump(subs, f) def main(): if args.interactive: script_file = input("Enter script file: ") output_file = input("Enter output file: ") output_format = input("Enter output format (mp3 or wav): ") subtitle_format = input("Enter subtitle format (srt, txt, or json): ") else: script_file = args.script output_file = args.output output_format = args.format subtitle_format = args.subtitle_format voice_id = choose_voice() text = get_text_from_file(Path(script_file)) # Generate audio and subtitles # ... (generate audio and subtitles using the stream_tts_to_mp3 function) # Save audio if output_format == 'mp3': output_path = Path(output_file) elif output_format == 'wav': output_path = Path(output_file.replace('.mp3', '.wav')) else: print(f"Invalid output format: {output_format}") sys.exit(1) # Save subtitles subtitle_path = Path(output_file.replace('.mp3', f'.{subtitle_format}')) save_subtitles(subs, subtitle_path) if __name__ == "__main__": main() You can run the script with the following arguments: python script.py -s script.txt -o output.mp3 -f mp3 -sf srt Or, in interactive mode: python script.py -i And then, follow the prompts to enter the script file, output file, output format, and subtitle format.